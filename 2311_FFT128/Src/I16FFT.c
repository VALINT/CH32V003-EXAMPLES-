/*
 * I16FFT.c
 *
 *  Created on: Jan 25, 2024
 *      Author: VAL
 */
#include "I16FFT.h"

const int16_t window[128] = {
2621, 2639, 2693, 2784, 2910, 3073, 3270, 3502, 3768, 4068, 4401, 4765, 5161, 5587, 6042, 6525,
7036, 7571, 8132, 8715, 9320, 9945, 10588, 11249, 11926, 12616, 13318, 14031, 14753, 15482, 16216,
16954, 17694, 18433, 19171, 19905, 20634, 21356, 22069, 22772, 23462, 24138, 24799, 25443, 26068, 26673,
27256, 27816, 28352, 28862, 29345, 29800, 30226, 30622, 30987, 31319, 31619, 31885, 32117, 32315, 32477,
32603, 32694, 32748, 32767, 32748, 32694, 32603, 32477, 32315, 32117, 31885, 31619, 31319, 30987, 30622,
30226, 29800, 29345, 28862, 28352, 27816, 27256, 26673, 26068, 25443, 24799, 24138, 23462, 22772, 22069,
21356, 20634, 19905, 19171, 18433, 17694, 16954, 16216, 15482, 14753, 14031, 13318, 12616, 11926, 11249,
10588, 9945, 9320, 8715, 8132, 7571, 7036, 6525, 6042, 5587, 5161, 4765, 4401, 4068, 3768, 3502, 3270,
3073, 2910, 2784, 2693, 2639};

// COS precounted table
const int16_t cos_tbl[128] = {
32767, 32727, 32609, 32412, 32137, 31785, 31356, 30851, 30272, 29621, 28897, 28105, 27244, 26318, 25329, 24278,
23169, 22004, 20787, 19519, 18204, 16845, 15446, 14009, 12539, 11038, 9511, 7961, 6392, 4807, 3211, 1607,
0, -1607, -3211, -4807, -6392, -7961, -9511, -11038, -12539, -14009, -15446, -16845, -18204, -19519, -20787,
-22004, -23169, -24278, -25329, -26318, -27244, -28105, -28897, -29621, -30272, -30851, -31356, -31785, -32137,
-32412, -32609, -32727, -32767, -32727, -32609, -32412, -32137, -31785, -31356, -30851, -30272, -29621, -28897,
-28105, -27244, -26318, -25329, -24278, -23169, -22004, -20787, -19519, -18204, -16845, -15446, -14009, -12539,
-11038, -9511, -7961, -6392, -4807, -3211, -1607, 0, 1607, 3211, 4807, 6392, 7961, 9511, 11038, 12539, 14009,
15446, 16845, 18204, 19519, 20787, 22004, 23169, 24278, 25329, 26318, 27244, 28105, 28897, 29621, 30272, 30851,
31356, 31785, 32137, 32412, 32609, 32727 };

// SIN precounted table
const int16_t sin_tbl[128] = {
0, 1607, 3211, 4807, 6392, 7961, 9511, 11038, 12539, 14009, 15446, 16845, 18204, 19519, 20787, 22004, 23169,
24278, 25329, 26318, 27244, 28105, 28897, 29621, 30272, 30851, 31356, 31785, 32137, 32412, 32609, 32727,
32767, 32727, 32609, 32412, 32137, 31785, 31356, 30851, 30272, 29621, 28897, 28105, 27244, 26318, 25329,
24278, 23169, 22004, 20787, 19519, 18204, 16845, 15446, 14009, 12539, 11038, 9511, 7961, 6392, 4807, 3211,
1607, 0, -1607, -3211, -4807, -6392, -7961, -9511, -11038, -12539, -14009, -15446, -16845, -18204, -19519,
-20787, -22004, -23169, -24278, -25329, -26318, -27244, -28105, -28897, -29621, -30272, -30851, -31356,
-31785, -32137, -32412, -32609, -32727, -32767, -32727, -32609, -32412, -32137, -31785, -31356, -30851,
-30272, -29621, -28897, -28105, -27244, -26318, -25329, -24278, -23169, -22004, -20787, -19519, -18204,
-16845, -15446, -14009, -12539, -11038, -9511, -7961, -6392, -4807, -3211, -1607
};

// Input sample order
const int8_t bit_invert[128] = {
0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120, 4, 68, 36, 100, 20, 84, 52, 116, 12,
76, 44, 108, 28, 92, 60, 124, 2, 66, 34, 98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122, 6, 70,
38, 102, 22, 86, 54, 118, 14, 78, 46, 110, 30, 94, 62, 126, 1, 65, 33, 97, 17, 81, 49, 113, 9, 73, 41,
105, 25, 89, 57, 121, 5, 69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125, 3, 67, 35, 99,
19, 83, 51, 115, 11, 75, 43, 107, 27, 91, 59, 123, 7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31,
95, 63, 127
};

void i16fft(int16_t* o_real, int16_t* o_imag)
{
    volatile uint8_t  N = 128;
    volatile uint16_t j = 0;
    int16_t* re; int16_t* im;

    // Apply window
    j = 0;
    re = o_real;
    im = o_imag;
    for (int16_t* i = o_real; i < o_real + N; i++)
    {
        *(im) = (int16_t)(((int32_t)(*i - 512) * window[j++]) >> 16);
        im++;
    }

    // First stage (2FFT butterflies)
    re = o_real;
    im = o_imag;
    for (int i = 0; i < N; i+=2)
    {
        // x0 = x0 + x1
        // x1 = x0 - x1
        int32_t x0, x1;
        x0 = *(o_imag + bit_invert[i]);
        x1 = *(o_imag + bit_invert[i + 1]);
        *re = (int16_t)(x0 + x1); re++;
        *re = (int16_t)(x0 - x1); re++;
        // Imaginary part at this step is equal to 0
        *(o_imag + bit_invert[i])     = 0;
        *(o_imag + bit_invert[i + 1]) = 0;
    }

    // Other FFT stages
    for (int l = 2; l < 8; l++)
    {
        uint8_t index = 0;
        uint8_t part_size = (uint8_t)N >> l;
        uint8_t oper_size = 1 << l-1;

        // Number of cycles (NC) equal to N / pow(2, l)
        // As example N = 128, l = 2 (FFT4) NC = 128/4 = 32. For FFT8 NC = 16, and so on.
        for (int j = 0; j < part_size; j++)
        {
            // Number of cycles is equal to pow(2,l)/2
            // // In one cycle computes 2 elements (n and n + pow(2, l)/2)
            // // As example FFT4 have 2 cycles, FFT8 have 4 cycles.
            for (int i = 0; i < oper_size; i++)
            {
                int32_t re1, re2, im1, im2;
                uint8_t pi = part_size * (index + i);
                re1 = *(o_real + index + i);
                re2 = *(o_real + index + i + oper_size);
                im1 = *(o_imag + index + i);
                im2 = *(o_imag + index + i + oper_size);

                int32_t re2c, re2s, im2c, im2s;
                re2c = (re2 *  cos_tbl[0x7F & pi]);
                re2s = (re2 * -sin_tbl[0x7F & pi]);
                im2c = (im2 *  cos_tbl[0x7F & pi]);
                im2s = (im2 * -sin_tbl[0x7F & pi]);

                // RESn (a + jb) = An + Wn * Bn+n/2
                *(o_real + index + i) = (int16_t)(re1 + (re2c >> 15) - (im2s >> 15));
                *(o_imag + index + i) = (int16_t)(im1 + (re2s >> 15) + (im2c >> 15));

                // RESn+n/2 (a + jb) = An - Wn * Bn+n/2
                *(o_real + index + i + oper_size) = (int16_t)(re1 + ((-re2c) >> 15) - ((-im2s) >> 15));
                *(o_imag + index + i + oper_size) = (int16_t)(im1 + ((-re2s) >> 15) + ((-im2c) >> 15));
            }
            index += (oper_size << 1);
        }
    }
    return;
}

uint16_t gapsqrt32(uint32_t a) {
        uint32_t rem = 0, root = 0;

        for (int i = 32 / 2; i > 0; i--) {
                root <<= 1;
                rem = (rem << 2) | (a >> (32 - 2));
                a <<= 2;
                if (root < rem) {
                        rem -= root | 1;
                        root += 2;
                }
        }
        return root >> 1;
}

static uint8_t frame = 0;

void i16mag(int16_t* i_real, int16_t* i_imag, uint8_t* output)
{
    int32_t res;
    int16_t *re;
    int16_t *im;
    uint8_t med;
    re = i_real; im = i_imag;
    for(uint8_t* i = output; i < output + 64; i++)
    {
        frame++; frame &= 0x3;
        res = (*re) * (*re) + (*im) * (*im);
        res = gapsqrt32(res);
        med = res >> 7;
        if((*i) < med){(*i) = med;}
        else if(*i > med) { (*i)--;}
        re++; im++;
    }
    return;
}
